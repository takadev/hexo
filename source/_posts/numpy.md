---
title: NumPyを試してみた
date: 2016-12-02 00:00:00
tags:
- "NumPy"
- "python"
- "プログラミング"
category: python
---
## NumPyについて
最近読み始めた「ゼロから作るDeep Learning」という本の最初にNumPyのことについて書かれていたので忘れないうちにメモしておきます。

## NumPyとは？
NumPyはPythonの数値計算数のためのライブラリで、高度な数学アルゴリズムや配列を操作するのに便利なメソッドが多く用意されており、その上パフォーマンスも良いという優れもののようです。
ディープラーニングの実装にはよく使われるそうです。
<!-- More -->

## Anacondaディストリビューションのインストール
NumPyを使うにはAnacondaディストリビューションを使うことをお進められたので、インストールしてみました。
pyenvでまずはインストールできる一覧を確認

```
pyenv install --list
...
  anaconda3-2.4.1
  anaconda3-2.5.0
  anaconda3-4.0.0
  anaconda3-4.1.0
  anaconda3-4.1.1
...
```

今回は最新の3-4.1.1をインストールしました。

```
pyenv install anaconda3-4.1.1
```

インストールできたか確認

```
pyenv versions
  system
  2.7.11
* 2.7.11/envs/tensorflow0.10　(set by /Users/hoge/.pyenv/version)
  3.5.1
  anaconda3-4.1.1
  tensorflow0.10
```

anacondaいますね。切り替えます。

```
pyenv global anaconda3-4.1.1
```

これで切り替わったのでNumPyが使えますね。

## NumPyを試してみる
NumPyが使えるようになったので早速試してみましょう。
iPythonで対話的に確認してみました。
`import nu`と入力した後にTABキーでnumpyがいますね

```
In [1]: import nu
numba    numbers  numexpr  numpy 
```

配列の計算をしてみました。NumPyで配列を扱うには`array()`を使用します。

```
In [2]: x = np.array([1.0,2.0,3.0])
In [3]: y = np.array([2.0,4.0,6.0])
In [4]: x + y
Out[4]: array([ 3.,  6.,  9.])
In [5]: x * y
Out[5]: array([  2.,   8.,  18.])
```

配列の要素数が同じ時はそれぞれの格要素同士で計算が行われるようです。
要素数が違う場合はエラーになってしまします。

## ブロードキャスト
先ほど、配列の計算は要素数が同じものでないとエラーになると書きましたが、例外もあります。ブロードキャストという機能があり、形状が異なる配列同士でも計算を行うことができます。

例えばこんな計算はできます。

```
In [6]: A = np.array([[1,2],[3,4]])
In [7]: A * 10
Out[7]: 
array([[10, 20],
       [30, 40]])
```

2次元配列のAに対してスカラ値の10を掛け合わせています。
この場合はブロードキャスト機能により、スカラ値の10が2x2の要素に自動的に拡大されて`[[10,10],[10,10]]`として計算されています。

## 要素へのアクセス
要素へのアクセスにはインデックスを指定します。

```
In [8]: B = np.array([[51,50],[9,10],[0,4]])
In [10]: print(B[0][0])
51
In [11]: print(B[0][1])
50
```

## 条件を指定して要素へアクセス
先ほどのBを1次元配列にします。

```
In [19]: B = np.array([[51,50],[9,10],[0,4]])
In [20]: B = B.flatten()
In [21]: print(B)
[51 50  9 10  0  4]
```

`flatten()`を使用すると多次元配列を1次元配列へ変換することができます。
この状態でBの要素の中で15より大きいものを取り出してみましょう。
インデックスに`B>15`を指定します。

```
In [22]: B[B>15]
Out[22]: array([51, 50])
```

`B>15`という式は15より大きい値の場合True、それ以外はFalseになるbooleanの配列を示しており、それをBのインデックスに指定することでTrueが指定された要素を取り出していることになります。

```
In [23]: B>15
Out[23]: array([ True,  True, False, False, False, False], dtype=bool)
```

## ndarrayオブジェクト
NumPyで配列を扱う際に`array()`を使うと書きましたが、これはndarrayというオブジェクトで実は中身はC言語の配列です。
Pythonのリスト型と比較して大規模な配列を扱う際の処理効率が非常に良くなっています。

ndarrayはN-dimensional arrayのことでN次元配列を扱えるクラスってことです。まんまですねw

## NumPyはなぜ速いのか？
Pythonはスクリプト言語なので静的言語よりは遅くなりますが、NumPyはndarrayのように主な実装をCやC++でか書いているので速いんです。


終わり。
